# -*- coding: utf-8 -*-
"""SSSfinalDL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11jWZ2IpV-VgAhUARKrd3PVp3YsBWvKfq
"""

import tensorflow as tf
from tensorflow.keras import layers, models
import matplotlib.pyplot as plt
import numpy as np
import os
from google.colab import files
from tensorflow.keras.utils import img_to_array, load_img
import zipfile

uploaded = files.upload()  # Upload dataset.zip

with zipfile.ZipFile("dataset.zip", 'r') as zip_ref:
    zip_ref.extractall(".")  # Extract to current directory

os.listdir("./dataset")  # Should show Cat, Dog, Horse folders

IMG_SIZE = (128, 128)
BATCH_SIZE = 4

# Load dataset
train_ds_raw = tf.keras.utils.image_dataset_from_directory(
    "dataset",
    labels="inferred",
    label_mode="int",
    image_size=IMG_SIZE,
    batch_size=BATCH_SIZE,
    shuffle=True
)

# âœ… Save class names BEFORE mapping
class_names = train_ds_raw.class_names
print("Classes:", class_names)

# Split into train/test (80% train, 20% test)
train_size = int(0.8 * len(train_ds_raw))
train_ds = train_ds_raw.take(train_size).map(lambda x, y: (x/255.0, y))
test_ds = train_ds_raw.skip(train_size).map(lambda x, y: (x/255.0, y))

model = models.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=(128,128,3)),
    layers.MaxPooling2D(2,2),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D(2,2),
    layers.Conv2D(128, (3,3), activation='relu'),
    layers.MaxPooling2D(2,2),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(3, activation='softmax')  # 3 classes
])

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

history = model.fit(train_ds, validation_data=test_ds, epochs=5)

# Upload your test image
uploaded = files.upload()  # Choose any image file

for filename in uploaded.keys():
    path = filename
    # Load and preprocess image
    img = load_img(path, target_size=IMG_SIZE)
    img_array = img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension

    # Predict
    prediction = model.predict(img_array)
    predicted_class = class_names[np.argmax(prediction)]

    # Show image with predicted class
    plt.imshow(img)
    plt.title(f"Predicted: {predicted_class}")
    plt.axis('off')
    plt.show()